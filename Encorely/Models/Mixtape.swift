import Foundation
import SwiftData

/// A curated collection of songs grouped by mood and personality preferences.
@Model
final class Mixtape {
    /// Unique stable identifier.
    @Attribute(.unique) var mixtapeID: String

    /// User-facing title.
    var title: String

    /// Whether this mixtape was generated by the AI engine.
    var isAIGenerated: Bool

    /// Comma-separated mood tags (e.g. "Energetic, Happy").
    var moodTags: String?

    /// Date this mixtape was created.
    var createdDate: Date

    /// Date this mixtape was last played.
    var lastPlayedDate: Date?

    /// Total play count.
    var playCount: Int

    /// Ordered collection of songs. SwiftData handles the relationship.
    @Relationship(deleteRule: .cascade, inverse: \Song.mixtape)
    var songs: [Song]

    init(
        title: String,
        isAIGenerated: Bool = false,
        moodTags: String? = nil
    ) {
        self.mixtapeID = UUID().uuidString
        self.title = title
        self.isAIGenerated = isAIGenerated
        self.moodTags = moodTags
        self.createdDate = Date()
        self.lastPlayedDate = nil
        self.playCount = 0
        self.songs = []
    }

    /// Parses the comma-separated mood tags into an array.
    var moodTagsArray: [String] {
        guard let tags = moodTags else { return [] }
        return tags.split(separator: ",").map { $0.trimmingCharacters(in: .whitespaces) }
    }

    /// Adds a mood tag if not already present.
    func addMoodTag(_ tag: String) {
        var tags = moodTagsArray
        guard !tags.contains(tag) else { return }
        tags.append(tag)
        moodTags = tags.joined(separator: ", ")
    }

    /// Removes a mood tag.
    func removeMoodTag(_ tag: String) {
        var tags = moodTagsArray
        tags.removeAll { $0 == tag }
        moodTags = tags.isEmpty ? nil : tags.joined(separator: ", ")
    }

    /// Records a play event.
    func trackPlay() {
        playCount += 1
        lastPlayedDate = Date()
    }

    /// Number of songs in this mixtape.
    var songCount: Int { songs.count }

    /// Total duration of all songs in seconds.
    var totalDuration: TimeInterval {
        songs.reduce(0) { $0 + $1.duration }
    }

    /// Derives the dominant mood from song mood tags.
    var dominantMood: Mood {
        var counts: [Mood: Int] = [:]
        for song in songs {
            if let tag = song.moodTag, let mood = Mood(rawValue: tag) {
                counts[mood, default: 0] += 1
            }
        }
        return counts.max(by: { $0.value < $1.value })?.key ?? .happy
    }
}
